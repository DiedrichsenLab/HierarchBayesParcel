import os  # to handle path information
import numpy as np
import matplotlib.pyplot as plt
import nibabel as nb
from numpy import exp,log,sqrt
import torch as pt
import arrangements as ar
import emissions as em
import full_model as fm
import spatial as sp

def train_rbm_to_mrf(width=10,K=5,N=200,theta_mu=20,theta_w=2,sigma2=0.5,
                    n_hidden = 100,n_epoch=20, batch_size=20,alpha=0.01):
    """Fits and RBM to observed activiy data, given a smooth true arrangement (mrf)
    Current version keeps the emission model stable and known

    Args:
        width (int): [description]. Defaults to 10.
        K (int): [description]. Defaults to 5.
        N (int): [description]. Defaults to 200.
        theta_mu (int): [description]. Defaults to 20.
        theta_w (int): [description]. Defaults to 2.
        sigma2 (float): [description]. Defaults to 0.5.
        n_hidden (int): [description]. Defaults to 100.
        n_epoch (int): [description]. Defaults to 20.
        batch_size (int): size of each learning batch

    Returns:
        [type]: [description]
    """

    lossU = 'abserr'
    lossY = 'sqerr'
    # Step 1: Create the true model
    grid = sp.SpatialGrid(width=width,height=width)
    arrangeT = ar.PottsModel(grid.W, K=K)
    emissionT = em.MixGaussian(K=K, N=N, P=grid.P)
    P = arrangeT.P

    # Step 2: Initialize the parameters of the true model
    arrangeT.random_smooth_pi(grid.Dist,theta_mu=theta_mu)
    arrangeT.theta_w = theta_w
    emissionT.random_params()
    emissionT.sigma2=sigma2
    MT = fm.FullModel(arrangeT,emissionT)

    # Step 3: Plot the prior of the true mode
    plt.figure(figsize=(7,4))
    grid.plot_maps(exp(arrangeT.logpi),cmap='jet',vmax=1,grid=[2,3])
    cluster = np.argmax(arrangeT.logpi,axis=0)
    grid.plot_maps(cluster,cmap='tab10',vmax=9,grid=[2,3],offset=6)

    # Step 4: Generate data by sampling from the above model
    U = MT.arrange.sample(num_subj=N,burnin=19) # These are the subjects
    Ytrain = MT.emission.sample(U) # This is the training data
    Ytest = MT.emission.sample(U)  # Testing data

    # Plot first 10 samples
    plt.figure(figsize=(10,4))
    grid.plot_maps(U[0:10],cmap='tab10',vmax=9,grid=[2,5])

    # Step 5: Generate partitions for region-completion testing
    num_part = 4
    p=pt.ones(num_part)/num_part
    part = pt.multinomial(p,arrangeT.P,replacement=True)

    # Make the model for fittinh
    rbm = ar.mpRBM(K=K,P=P,nh=n_hidden)
    yerr_train = np.zeros(n_epoch)
    yerr_test1 = np.zeros(n_epoch)
    yerr_test2 = np.zeros(n_epoch)
    uerr_train = np.zeros(n_epoch)
    uerr_test1 = np.zeros(n_epoch)
    uerr_test2 = np.zeros(n_epoch)

    emloglik_train = pt.tensor(MT.emission.Estep(Y=Ytrain),dtype=pt.get_default_dtype())
    emloglik_test = pt.tensor(MT.emission.Estep(Y=Ytest),dtype=pt.get_default_dtype())
    Utrain = pt.softmax(emloglik_train,1)
    Utest =  pt.softmax(emloglik_test,1)

    for epoch in range(n_epoch):
        # Get test error
        Eh = rbm.epos(Utrain)
        uerr_train[epoch] = rbm.evaluate_test(Utrain,Eh,lossfcn=lossU)
        uerr_test1[epoch]= rbm.evaluate_test(Utest,Eh,lossfcn=lossU)
        uerr_test2[epoch]= rbm.evaluate_completion(Utest,part,lossfcn=lossU)
        print(f'epoch {epoch:2d} Train: {uerr_train[epoch]:.1f}, Test1: {uerr_test1[epoch]:.1f}, Test2: {uerr_test2[epoch]:.1f}')

        for b in range(0,N-batch_size+1,batch_size):
            ind = range(b,b+batch_size)
            rbm.epos(Utrain[ind,:,:])
            u,Eh=rbm.eneg_CDk(Utrain[ind,:,:],iter=1)
            rbm.Mstep(alpha=alpha)

    t=np.arange(0,n_epoch)
    plt.figure(figsize=(6,4))
    plt.plot(t,uerr_train,'k--',label='training')
    plt.plot(t,uerr_test1,'r',label='test1')
    plt.plot(t,uerr_test2,'r:',label='test2')


    pass

if __name__ == '__main__':
    train_rbm_to_mrf(N=20,batch_size=20)
    # train_RBM()